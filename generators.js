/* jshint node: true */
'use strict';

var debug = require('cog/logger')('generators');
var detect = require('./detect');
var defaults = require('cog/defaults');

var mappings = {
  offer: {
    // audio toggle
    // { audio: false } in peer connection config turns off audio
    audio: function(c) {
      c.mandatory = c.mandatory || {};
      c.mandatory.OfferToReceiveAudio = true;
    },

    // video toggle
    // { video: false } in peer connection config turns off video
    video: function(c) {
      c.mandatory = c.mandatory || {};
      c.mandatory.OfferToReceiveVideo = true;
    }
  },

  create: {
    // data enabler
    data: function(c) {
      if (! detect.moz) {
        c.optional = (c.optional || []).concat({ RtpDataChannels: true });
      }
    },

    dtls: function(c) {
      if (! detect.moz) {
        c.optional = (c.optional || []).concat({ DtlsSrtpKeyAgreement: true });
      }
    }
  }
};

// initialise known flags
var knownFlags = ['video', 'audio', 'data'];

/**
  ## rtc/generators

  The generators package provides some utility methods for generating
  constraint objects and similar constructs.

  ```js
  var generators = require('rtc/generators');
  ```

**/

/**
  ### generators.config(config)

  Generate a configuration object suitable for passing into an W3C
  RTCPeerConnection constructor first argument, based on our custom config.
**/
exports.config = function(config) {
  return defaults(config, {
    iceServers: []
  });
};

/**
  ### generators.connectionConstraints(flags, constraints)

  This is a helper function that will generate appropriate connection
  constraints for a new `RTCPeerConnection` object which is constructed
  in the following way:

  ```js
  var conn = new RTCPeerConnection(flags, constraints);
  ```

  In most cases the constraints object can be left empty, but when creating
  data channels some additional options are required.  This function
  can generate those additional options and intelligently combine any
  user defined constraints (in `constraints`) with shorthand flags that
  might be passed while using the `rtc.createConnection` helper.
**/
exports.connectionConstraints = function(flags, constraints) {
  var generated = {};
  var m = mappings.create;
  var out;

  // iterate through the flags and apply the create mappings
  Object.keys(flags || {}).forEach(function(key) {
    if (m[key]) {
      m[key](generated);
    }
  });

  // generate the connection constraints
  out = defaults({}, constraints, generated);
  debug('generated connection constraints: ', out);

  return out;
};

/**
  ### generators.mediaConstraints(flags, context)

  Generate mediaConstraints appropriate for the context in which they are
  being called (i.e. either constructing an RTCPeerConnection object, or
  on the `createOffer` or `createAnswer` calls).
**/
exports.mediaConstraints = function(flags, context) {
  // create an empty constraints object
  var constraints = {
    optional: [{ DtlsSrtpKeyAgreement: true }]
  };

  // provide default mandatory constraints for the offer
  if (context === 'offer') {
    constraints.mandatory = {
      OfferToReceiveVideo: false,
      OfferToReceiveAudio: false
    };
  }

  // get the mappings for the context (defaulting to the offer context)
  var contextMappings = mappings[context || 'offer'] || {};

  // if we haven't been passed an array for flags, then return the constraints
  if (! Array.isArray(flags)) {
    flags = parseFlags(flags);
  }

  flags.map(function(flag) {
    if (typeof contextMappings[flag] == 'function') {
      // mutate the constraints
      contextMappings[flag](constraints);
    }
  });

  return constraints;
};

/**
  ### parseFlags(opts)

  This is a helper function that will extract known flags from a generic
  options object.
**/
var parseFlags = exports.parseFlags = function(options) {
  // ensure we have opts
  var opts = options || {};

  // default video and audio flags to true if undefined
  opts.video = opts.video || typeof opts.video == 'undefined';
  opts.audio = opts.audio || typeof opts.audio == 'undefined';

  return Object.keys(opts || {})
    .filter(function(flag) {
      return opts[flag];
    })
    .map(function(flag) {
      return flag.toLowerCase();
    })
    .filter(function(flag) {
      return knownFlags.indexOf(flag) >= 0;
    });
};